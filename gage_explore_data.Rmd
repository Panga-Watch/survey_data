---
title: "Gage Survey Data Explore"
author: "Gage Clawson"
date: "10/1/2019"
output: html_document
---

## Summary
First look through of data for Gage 
 
## Data Source 
Personal Interviews
 
## Reference 
Panga Watch
 
## Downloaded
September 30, 2019
 
Time range: 
2019
 
## Format
comma separated values

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(dplyr)
```

```{r}
master_surv_resp <- read_csv("master_survey_resp.csv")
```

Determine if I have questions about variables in the data

```{r}
## survey_type
unique(master_surv_resp$survey_type)
#[1] "D"    "FLAG"
# there is only one "FLAG" observation....
## What does "FLAG" mean? "D" means "Data Collection". How come there are no "training" or "t" observations, as specified in "Survey Key.xlsx"? 

## survey_id
length(unique(master_surv_resp$survey_id))
## makes sense... each observation has it's own survey_id. The first number corresponds to the administered location. 

## survey_version
unique(master_surv_resp$survey_version)
#16. Corresponds to each choice experiment. 

## interviewer
# name of each interviewer. There are three "JS"'s. What do the *'s mean? 

## interviewer_Org 
# the interviewer's organization
unique(master_surv_resp$interviewer_Org)
# we had 4 different organizations helping to administer surveys!

## community
unique(master_surv_resp$community)
# [1] "RAJ" "MAK" "MNC" "PSC" "ALT" "TTN" "WKB"

count(master_surv_resp, vars = community)
# ALT	37			
# MAK	59			
# MNC	27			
# PSC	46			
# RAJ	18			
# TTN	4			
# WKB	14	

# What is "WKB"? Not specified in "Survey Key.xlsx" -- probably Wakatobi, Indonesia 
# What does "TTN" stand for? 
# "MAK" means "Muara Angke".

## gear columns
# Each gear column specifies whether they use a certain type of gear or not. 1 for yes, 0 for no.

## positive_tracking_tech_one
## positive_tracking_tech_two
## negative_tracking_tech_one
## negative_tracking_tech_two
# do these need to be translated? 

## wtp_1 
# $5 

## wtp_2 
# $10

## wtp_3 
# $15

## wtp_4 
# $20

## wtr_1
# $5

## wtr_2
# $10

## wtr_3 
# $15

## wtr_4
# $20

############## What does it mean when there are NAs in the above columns? 

## tracking_negative
## tracking_positive 
# do these need to be translated? 

## design_**
# Note to self: Should check these to see that none of them have chosen > 3 benefits... probably some sort of filter on each of these columns or something...

## text_vms_adoption
# translate? 

## target_species_*** 
# translate?

## fraction_**
# Note to self: check to see if these all add up to 100%

## other_fraction
# translate?

## fishing_org_type
# what do NAs in this column mean? 

## other_access
# translate 

## other_restriction
# translate 

## rank_***
# is there a reason there are NAs in these? For instance, an observation has rank_1,2,3 all NA, but rank_four is filled out.

## catch_trends 
# this is ok

## opinion_*
# why are there a couple NAs?

## trust_*
# looks ok. Maybe a couple of NAs...

## income
# do we need to change the currency?


```

General notes: 
 - Confused about what NAs in the dataset mean. Could they skip questions? 
 - Is there a translated version of the dataset? 
 
```{r}
packages <- read_csv("packages.csv")
```

```{r}

####### NOTE: THIS IS ONLY WORKING WITH THE CHOICE EXPERIMENT.... STILL NEED TO TIDY THE REST OF THE DATA #######

version_to_package <- read_csv("version_to_package.csv") #read in version to package conversion
# sos	1 = no, 2 = yes
# info 	1 = non, 2 = anon
# own	1 = fishers, 2 = industry, 3 = govt, 4 = public access

## this is giving us tidy data for the choice experiment. If they had a choice between package one and package 2, and chose package one, and then had a choice between package one and no package, and still chose package one, we assign a "1" for adoption. Likewise for if they originally chose package 2. If they chose no package, then both packages receive a "0" for adoption. Is this what we want to do? This eliminates the "tradeoff" aspect and makes this a classical "discrete choice experiment". We can still look into a model for the "tradeoff" between two packages, but for now this will tell us a "probability of adoption" with a binomial logistic regression model. 

survey <- master_surv_resp %>%
  dplyr::select(survey_id, survey_version, choice, package_nopackage)

survey_matched <- survey %>%
  left_join(version_to_package, by = "survey_version") # match to get 2 "package"'s for each respondent. This way we will have a "yes" or a "no" for each package a respondent was asked about.  

survey_adopt_1_2 <- survey_matched %>%
  mutate(adopt_one  = 
           case_when(choice ==1 & package_nopackage == 1 ~ 1 , 
         choice == 1 & package_nopackage == 0 ~ 0),
         adopt_two = 
         case_when(choice == 2 & package_nopackage == 1 ~ 1,
         choice == 2 & package_nopackage == 0 ~ 0)) # logic for the packages they chose. Did they adopt or not...
%>%
  mutate(adopt_one =
           ifelse(is.na(adopt_one) == TRUE, 0, adopt_one), # catches all instances where an adopt_*** should be assigned "0"
         adopt_two =
           ifelse(is.na(adopt_two) == TRUE,  0, adopt_two) # catches all instances where an adopt_*** should be assigned "0" 
         )

survey_adopt_1 <- survey_adopt_1_2[seq(1, nrow(survey_adopt_1_2), 2), ] #grab every other row starting from row one. This way we get all of the corret rows for the "adopt_one" column

survey_adopt_2 <- survey_adopt_1_2[seq(2, nrow(survey_adopt_1_2), 2), ] #grab every other row starting from row two. This way we get all of the corret rows for the "adopt_two" column


survey_adopt_1_final <- survey_adopt_1 %>%
  select(-7)  %>% # deselect adopt_two column
  rename("adopt" = adopt_one) #rename adopt_one column to "adopt"

survey_adopt_2_final <- survey_adopt_2 %>%
  select(-6) %>% # deselect adopt_two column
  rename("adopt" = adopt_two) # rename adopt_one column to "adopt"

survey_adopt_final <- rbind(survey_adopt_1_final, survey_adopt_2_final)

survey_adopt_final <- arrange(survey_adopt_final, survey_id)

ifelse(survey_adopt_final$package_nopackage ==1, survey_adopt_final$adopt %in% c(0,1), survey_test_final$adopt == 0) ## test to see if logic is correct



survey_matched_levels_final <- survey_adopt_final %>%
  left_join(packages, by = "package") %>% #join with all packages to match our data with correct attributes
  mutate(sos = as.factor(sos), info = as.factor(info), own = as.factor(own)) %>%
  dplyr::select(survey_id, sos, info, own, adopt) 


str(survey_matched_levels_final)
sum(survey_matched_levels_final$adopt == 1) #163
sum(survey_matched_levels_final$adopt == 0) #247
## way more "no"'s than "yes"'s
```

```{r}
#binomial logistic regression
survey_logit <- glm(adopt ~ sos + info + own, family = "binomial", data = survey_matched_levels_final) # feed data into a binomial logistic regression to obtain probability of acceptance
# sos	1 = no, 2 = yes
# info 	1 = non, 2 = anon
# own	1 = fishers, 2 = industry, 3 = govt, 4 = public access
#adopt : 1 = accept, 0 = decline
summary(survey_logit) #check the model
```


